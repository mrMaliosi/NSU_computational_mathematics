import numpy as np
import matplotlib.pyplot as plt

# Параметры
L = 1.0  # Длина области
Nx = 100  # Число узлов
dx = L / Nx  # Шаг по пространству
dt = 0.01  # Шаг по времени
T = 2.0  # Время моделирования
a = 1.0  # Скорость переноса
b = 0.5  # Скорость для второй части области

# Параметры для функции f(u)
c = 1.0  # Константа для f(u) = cu
# Для второй функции
def f(u):
    return u**2 / 2  # f(u) = u^2 / 2

# Сетка по пространству
x = np.linspace(-1, 1, Nx, endpoint=False)

# Начальное условие (например, линейная функция для простоты)
u_initial = np.where(x < 0, a, b)

# Функция для применения схемы Лакса-Вендорфа
def lax_wendroff(u, a, dx, dt, f):
    u_new = np.zeros_like(u)
    
    # Внутренние узлы
    for i in range(1, len(u) - 1):
        u_new[i] = u[i] - a * dt / (2 * dx) * (u[i+1] - u[i-1]) + 0.5 * (a * dt / dx)**2 * (u[i+1] - 2*u[i] + u[i-1]) + dt * f(u[i])
    
    # Граничные условия: периодические
    #u_new[0] = u_new[-1]
    
    # Граничные условия: фиксируем значения на границах
    u_new[0] = a
    u_new[-1] = b
    
    return u_new

# Моделирование во времени для f(u) = cu
u = u_initial.copy()
t_steps = int(T / dt)
for t in range(t_steps):
    u = lax_wendroff(u, a, dx, dt, lambda u: c * u)  # Используем f(u) = cu

# Визуализация для f(u) = cu
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.plot(x, u, label=f'Решение для f(u) = {c}*u')
plt.title('Решение с f(u) = cu')
plt.xlabel('x')
plt.ylabel('u(x, T)')
plt.grid(True)

# Моделирование во времени для f(u) = u^2 / 2
u = u_initial.copy()
for t in range(t_steps):
    u = lax_wendroff(u, a, dx, dt, f)  # Используем f(u) = u^2 / 2

# Визуализация для f(u) = u^2 / 2
plt.subplot(1, 2, 2)
plt.plot(x, u, label='Решение для f(u) = u^2 / 2')
plt.title('Решение с f(u) = u^2 / 2')
plt.xlabel('x')
plt.ylabel('u(x, T)')
plt.grid(True)

plt.tight_layout()
plt.show()
